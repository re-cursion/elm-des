module Main exposing (..)

-- import ResourceView exposing (drawArrowWithQueue, drawResource)

import Browser
import Dict exposing (Dict)
import EventTime exposing (EventTime(..))
import Html exposing (Html, button, div, li, ul)
import Html.Events exposing (onClick)
import Queue exposing (..)
import Resource exposing (..)
import Svg exposing (svg)
import Svg.Attributes exposing (..)
import Types exposing (..)
import Work exposing (Work(..), WorkID(..))


init =
    { resources =
        Dict.fromList
            [ ( 1, Resource (Just (QueueID 3)) [ QueueID 1 ] Idle Nothing )
            , ( 2, Resource (Just (QueueID 1)) [ QueueID 2 ] Idle Nothing )
            , ( 3, Resource (Just (QueueID 2)) [ QueueID 3 ] Idle Nothing )
            ]
    , queues =
        Dict.fromList
            [ ( 1
              , { tasks =
                    [ Work (WorkID 1) (Dict.fromList [ ( 1, EventTime 5 ) ])
                    , Work (WorkID 2) (Dict.fromList [ ( 2, EventTime 5 ) ])
                    , Work (WorkID 3) (Dict.fromList [ ( 3, EventTime 5 ) ])
                    ]
                }
              )
            , ( 2, { tasks = [] } )
            , ( 3, { tasks = [] } )
            ]
    , events =
        []
    , currentTime = EventTime 0
    }


type Msg
    = StepSimulation


update : Msg -> Model -> Model
update msg model =
    case msg of
        StepSimulation ->
            processNextStep model


processNextStep : Model -> Model
processNextStep model =
    -- handle all resources: service idle resources. Create new events for all idle resources to check the queues
    let
        idleResources =
            Dict.filter (\_ resource -> resource.inputQueue /= Nothing && not resource.busy) model.resources

        updatedEvents =
            model.events ++ (idleResources |> Dict.keys |> List.map (\id -> Event model.currentTime (ResourceID id) FetchTask))

        -- sort events by time
        sortedEvents =
            List.sortWith compareEventTimes updatedEvents

        ( currentEvents, laterEvents ) =
            List.partition (\e -> (e |> eventTime |> fetchTime) <= (model.currentTime |> fetchTime)) sortedEvents

        stepPlusOneModel =
            executeOnCurrentEvents model currentEvents laterEvents
    in
    { stepPlusOneModel
        | currentTime = Time ((stepPlusOneModel.currentTime |> fetchTime) + 1)
        , events = stepPlusOneModel.events
    }


partitionResourceMatchingEvent : Event -> List Resource -> ( Maybe Resource, List Resource )
partitionResourceMatchingEvent event resources =
    let
        ( matching, remaining ) =
            List.partition (\n -> n.id == eventResourceID event) resources
    in
    case matching of
        n :: _ ->
            ( Just n, remaining )

        [] ->
            ( Nothing, resources )


partitionInputQueueMatchingResource : Maybe Resource -> List Queue -> ( Maybe Queue, List Queue )
partitionInputQueueMatchingResource maybeResource queues =
    case maybeResource of
        Just n ->
            let
                ( matchingQueues, remainingQueues ) =
                    List.partition (\q -> Maybe.withDefault (QueueID -1) n.inputQueue == q.id) queues
            in
            case matchingQueues of
                [] ->
                    ( Nothing, queues )

                q :: qtail ->
                    -- take the first input queue
                    ( Just q, qtail ++ remainingQueues )

        Nothing ->
            ( Nothing, queues )


compareTaskLength : Queue -> Queue -> Order
compareTaskLength q1 q2 =
    compare (List.length q1.tasks) (List.length q2.tasks)


partitionOutputQueueMatchingResource : Maybe Resource -> Dict QueueID Queue -> Maybe Queue
partitionOutputQueueMatchingResource maybeResource queues =
    case maybeResource of
        Just n ->
            let
                ( matchingQueues, _ ) =
                    List.partition (\q -> List.member q.id n.outputQueues) queues
            in
            case matchingQueues of
                [] ->
                    ( Nothing, queues )

                q :: _ ->
                    -- take the first output queue
                    let
                        leastBusiestQueue =
                            matchingQueues |> List.sortWith compareTaskLength |> List.head
                    in
                    case leastBusiestQueue of
                        Just lbq ->
                            ( Just lbq, queues |> List.filter (\x -> x.id /= lbq.id) )

                        Nothing ->
                            ( Nothing, queues )

        Nothing ->
            ( Nothing, queues )


fetchTaskFromResource : Maybe Resource -> Maybe Work
fetchTaskFromResource maybeResource =
    maybeResource |> Maybe.andThen .currentTask



-- case maybeResource of
--     Just n ->
--         n.currentTask
--     Nothing ->
--         Nothing


fetchTaskFromQueue : Time -> List Event -> ( List Resource, List Queue ) -> ( List Resource, List Queue, List Event )
fetchTaskFromQueue currentTime fetchTaskEvents ( resources, queues ) =
    case fetchTaskEvents of
        [] ->
            ( resources, queues, [] )

        -- no more fetch events to process
        event :: remainingEvents ->
            let
                ( resource, remainingResources ) =
                    partitionResourceMatchingEvent event resources

                -- select resource based on event
                ( queue, remainingQueues ) =
                    partitionInputQueueMatchingResource resource queues

                ( updatedResource, updatedQueue, eventToBeScheduled ) =
                    case ( resource, queue ) of
                        ( Just n, Just q ) ->
                            case q.tasks of
                                -- no task to fetch
                                [] ->
                                    ( Nothing, Nothing, [] )

                                hd :: tl ->
                                    ( Just { n | busy = True, currentTask = Just hd }
                                    , Just { q | tasks = tl }
                                    , [ Event (addTimes currentTime hd.serviceTime) n.id ServiceComplete ]
                                      -- schedule service complete event
                                    )

                        _ ->
                            ( Nothing, Nothing, [] )

                -- no updates if resource or queue not found
                ( updatedResources, updatedQueues ) =
                    case ( updatedResource, updatedQueue ) of
                        ( Just un, Just uq ) ->
                            ( List.map
                                (\n ->
                                    if n.id == un.id then
                                        un

                                    else
                                        n
                                )
                                resources
                            , List.map
                                (\q ->
                                    if q.id == uq.id then
                                        uq

                                    else
                                        q
                                )
                                queues
                            )

                        _ ->
                            ( resources, queues )

                -- if there are more fetch events, process them (recursively)
                ( upResources, upQueues, upEvents ) =
                    fetchTaskFromQueue currentTime remainingEvents ( updatedResources, updatedQueues )
            in
            ( upResources, upQueues, eventToBeScheduled ++ upEvents )



-- accumulate scheduled events


pushTaskToQueue : List Event -> ( List Resource, Dict QueueID Queue ) -> ( List Resource, Dict QueueID Queue )
pushTaskToQueue serviceCompleteEvents ( resources, queues ) =
    case serviceCompleteEvents of
        [] ->
            ( resources, queues )

        -- no service complete events to process
        event :: remainingEvents ->
            let
                ( resource, remainingResources ) =
                    partitionResourceMatchingEvent event resources

                -- select resource based on event
                ( queue, remainingQueues ) =
                    partitionOutputQueueMatchingResource resource queues

                task =
                    fetchTaskFromResource resource

                ( updatedResources, updatedQueues ) =
                    case ( resource, queue, task ) of
                        ( Just n, Just q, Just t ) ->
                            ( { n | busy = False, currentTask = Nothing } :: remainingResources
                            , { q | tasks = q.tasks ++ [ t ] } :: remainingQueues
                            )

                        _ ->
                            ( resources, queues )
            in
            pushTaskToQueue remainingEvents ( updatedResources, updatedQueues )



-- if there are more service complete events, process them (recursively)


isServiceCompleteEvent : Event -> Bool
isServiceCompleteEvent e =
    case e |> eventType of
        ServiceComplete ->
            True

        _ ->
            False


isFetchTaskEvent : Event -> Bool
isFetchTaskEvent e =
    case e |> eventType of
        FetchTask ->
            True

        _ ->
            False


executeOnCurrentEvents : Model -> List Event -> List Event -> Model
executeOnCurrentEvents model currentEvents laterEvents =
    let
        serviceCompleteEvents =
            List.filter isServiceCompleteEvent currentEvents

        fetchTaskEvents =
            List.filter isFetchTaskEvent currentEvents

        ( changedResources, changedQueues, newEvents ) =
            ( model.resources, model.queues )
                |> pushTaskToQueue serviceCompleteEvents
                |> fetchTaskFromQueue model.currentTime fetchTaskEvents

        nextModelEvents =
            laterEvents ++ newEvents
    in
    { model | resources = changedResources, queues = changedQueues, events = nextModelEvents }


view : Model -> Html Msg
view model =
    div []
        [ Html.text "Minimal Resource Simulation"
        , svgView model
        , button [ onClick StepSimulation ] [ Html.text "Step Simulation" ]
        , Html.text ("Current time: " ++ String.fromInt (model.currentTime |> fetchTime))
        , Html.text "\nQueues:"
        , ul [] (List.map (\q -> li [] [ Html.text ("Queue " ++ String.fromInt (fetchQueueID q.id) ++ ": " ++ String.join ", " (List.map (\t -> String.fromInt (fetchWorkID t.id)) q.tasks)) ]) model.queues)
        , Html.text "\nEvents:"
        , ul [] (List.map (\e -> li [] [ Html.text (eventToString e) ]) (List.sortWith compareEventTimes model.events))
        ]


eventToString : Event -> String
eventToString e =
    let
        nid =
            e |> eventResourceID |> fetchResourceID |> String.fromInt

        time =
            e |> eventTime |> fetchTime |> String.fromInt

        etype =
            case e |> eventType of
                ServiceComplete ->
                    "ServiceComplete at resource " ++ nid

                FetchTask ->
                    "FetchTask at resource " ++ nid
    in
    time ++ ": " ++ etype


svgView : Model -> Html msg
svgView model =
    let
        queueArrows =
            List.concatMap
                (\q ->
                    let
                        fromResources =
                            List.filter (\n -> List.member q.id n.outputQueues) model.resources

                        toResource =
                            List.filter (\n -> n.inputQueue == Just q.id) model.resources |> List.head
                    in
                    case ( fromResources, toResource ) of
                        ( fromN :: _, Just toN ) ->
                            [ drawArrowWithQueue fromN toN q ]

                        _ ->
                            []
                )
                model.queues
    in
    svg [ width "600", height "500", Svg.Attributes.style "border:1px solid #ccc; background:#fafafa;" ]
        (queueArrows ++ List.map drawResource model.resources)


main : Program () Model Msg
main =
    Browser.sandbox { init = init, update = update, view = view }
